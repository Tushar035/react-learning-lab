React useRef
--------------
1. What is useRef?
-----------------------------
useRef is a React Hook that:
 Stores a mutable value  
 Persists across re-renders
 Does NOT trigger re-render when updated
 Can directly reference a DOM element

2. Basic Syntax
----------------
import { useRef } from "react";

const ref = useRef(initialValue);
It returns:
ref=
{
  current: initialValue
}

You access value like:
ref.current

3. Why Not Just Use State?
---------------------------
| Feature                       | useState | useRef |
| ----------------------------- | -------- | ------ |
| Causes re-render?             |  Yes    |  No   |
| Stores value between renders? |  no    |  Yes  |
| Used for DOM access?          |  No     |  Yes  |
| Mutable directly?             |  No     |  Yes  |

If updating value should NOT re-render UI → use useRef


4. useRef for DOM Access (Most Common Use Case)
----------------------------------------------
  Example: Focus Input Automatically

uncontrolled component:
import React, { useRef, useEffect } from "react";

function FocusInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} placeholder="Enter name" />;
}


What Happens?
------------
1. React renders input
2. ref gets attached to DOM
3. inputRef.current now points to input element
4. focus() runs


5. Real World UI Example – Scroll to Section
---------------------------------------------

function ScrollExample() {
  const sectionRef = useRef(null);

  const scrollToSection = () => {
    sectionRef.current.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <>
      <button onClick={scrollToSection}>Go to Section</button>

      <div style={{ height: "100vh" }}></div>

      <div ref={sectionRef}>
        <h2>Target Section</h2>
      </div>
    </>
  );
}


Use Cases:
---------------
 Scroll to error message
 Scroll to form field
 Scroll to top button
 FAQ navigation


6. Storing Previous Value (Very Important Interview Question)
-------------------------------------------------------------
Example: Track Previous Count

import React, { useState, useEffect, useRef } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = useRef();

  useEffect(() => {
    prevCount.current = count;  - storing value in current
  }, [count]);

  return (
    <>
      <h2>Current: {count}</h2>
      <h2>Previous: {prevCount.current}</h2>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </>
  );
}


Why useRef?
------------------
If we stored previous value in state → it would cause infinite re-renders.

7. Store Interval or Timeout ID
----------------------------------
Very practical example.

function Timer() {
  const intervalRef = useRef(null);
  const [count, setCount] = useState(0);

  const start = () => {
    intervalRef.current = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
  };

  const stop = () => {
    clearInterval(intervalRef.current);
  };

  return (
    <>
      <h1>{count}</h1>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
    </>
  );
}


Why not state?
------------------
Because interval ID doesn’t affect UI → no need to re-render.

8. Avoid Re-Creation of Expensive Objects
-----------------------------------------

function ExpensiveObject() {
  const dataRef = useRef(new Map());

  const addData = () => {
    dataRef.current.set(Date.now(), "value");
  };

  return <button onClick={addData}>Add</button>;
}


 Map persists
 Not recreated every render


9. useRef vs createRef
--------------------------

| createRef                    | useRef                        |
| ---------------------------- | ----------------------------- |
| Used in Class components     | Used in Functional components |
| Creates new ref every render | Persists across renders       |


10. Forwarding Refs (Advanced)
-------------------------------
When parent wants to access child DOM:

import React, { forwardRef } from "react";

const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

function Parent() {
  const inputRef = useRef(null);

  return (
    <>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>
        Focus
      </button>
    </>
  );
}

11. useRef for Mutable Flag (Avoid Multiple API Calls)
------------------------------------------------------

function FetchData() {
  const hasFetched = useRef(false);

  useEffect(() => {
    if (!hasFetched.current) {
      fetchDataFromAPI();
      hasFetched.current = true;
    }
  }, []);
}


Useful in:
----------
 Strict Mode double rendering
 Prevent duplicate requests

12. Common Interview Questions
-------------------------------
Does updating useRef cause re-render?
No

Can we use it instead of state?
Only when UI does NOT depend on that value.

Why does it persist?
Because React keeps same ref object between renders.

13. When NOT to Use useRef
---------------------------
	To store UI state
	For derived values
	To replace useState everywhere

14. Real Production Use Cases
-----------------------------
1. Form validation scroll
2. Auto focus fields
3. Video/audio control
4. Store previous props
5. Store WebSocket instance
6. Debounce timers
7. Prevent re-render performance issues
8. Detect click outside component

15. Click Outside Detection (Advanced Real Example)
----------------------------------------------------

function Modal({ onClose }) {
  const modalRef = useRef();

  useEffect(() => {
    function handleClick(e) {
      if (!modalRef.current.contains(e.target)) {
        onClose();
      }
    }

    document.addEventListener("mousedown", handleClick);
    return () => {
      document.removeEventListener("mousedown", handleClick);
    };
  }, []);

  return (
    <div ref={modalRef} className="modal">
      <h2>Modal Content</h2>
    </div>
  );
}


Mental Model
------------------
Think of useRef as:

> “A box that React keeps between renders, but changing it doesn’t tell React to re-render.”

Senior-Level Understanding
--------------------------
 useRef is synchronous
 It does not participate in React render cycle
 It’s perfect for integration with:

   DOM
   Third-party libraries
   Timers
   Imperative APIs

Final Summary
----------------
useRef is used for:

 DOM access
 Persisting mutable values
 Storing previous state
 Timers & intervals
 Performance optimization
 Imperative logic

2 important scenarios when and when not to use ref attribute? 
First Important Understanding
------------------------------------
useRef() does NOT automatically connect to the DOM.
It only creates a box (container object).
React connects that box to a DOM element only when you use the ref attribute.

Step 1: What useRef() Actually Returns

When you write:

js
const sectionRef = useRef(null);

React creates an object like this:

js
{
  current: null
}

That’s it.
It’s just a plain object with a property called current.
It does NOT know anything about DOM yet.

Then How Does It Get DOM Element?
---------------------------------
Because you write:

jsx
<div ref={sectionRef}>

That ref attribute is special.
When React sees:

ref={sectionRef}


It understands:
-----------------
"After rendering this div into the real DOM, put the DOM node inside sectionRef.current"

So React does something like:

js
sectionRef.current = actualDOMNode;

Layman Analogy
----------------
Think of useRef like giving React:

“Here is an empty box. After you create the element, please put it inside this box.”

If you don’t attach the box to any element using ref={...}, React doesn’t know what to store in it.

---

Now Your First Question

Why ref attribute is not given in Counter example?
---------------------------------------------------
Look at this:
js
const prevCount = useRef();

Here we are NOT trying to store a DOM element.

We are using it like:
prevCount.current = count;

So this time, we are manually storing a value in the box.
This is NOT a DOM reference use case.
It’s just a persistent container.

Important: useRef Has Two Use Cases

1️.DOM reference
----------------
jsx
<div ref={sectionRef}>

React fills current with DOM element.

2️.Persistent mutable value
-------------------------------------
js
const prevCount = useRef();
prevCount.current = count;

Here YOU control what goes inside .current.
React is not involved.

How Does React Decide Which DOM Element To Store?
----------------------------------------------------
It does NOT decide automatically.
It only stores the element where you attach:

ref={sectionRef}

Example:

<input ref={myRef} />

React does:
myRef.current = inputDOMNode

If you attach it to:

<button ref={myRef} />

Then:
myRef.current = buttonDOMNode

React just connects whatever element you attach it to.
It doesn’t "choose".

Under the Hood (Simple Internal Flow)
------------------------------------
Render Phase:
----------------
useRef() creates object { current: null }

Commit Phase:
React sees ref={sectionRef}
React assigns DOM node to sectionRef.current

On unmount:
React sets sectionRef.current = null

Why Doesn’t Counter Need ref Attribute?
-----------------------------------
Because we are not referencing DOM.

We are using ref like this:
useRef = "persistent variable that does not cause re-render"
It survives across renders but does not trigger re-render.


Why Not Just Use useState Instead?
----------------------------------
Because:
 useState → triggers re-render
 useRef → does NOT trigger re-render

For previous value tracking, we don't want re-render.

That’s why:
prevCount.current = count;

is perfect.

Final Clear Comparison

| Case          | ref attribute needed? | Who sets .current? |
| ------------- | --------------------- | -------------------- |
| DOM reference | Yes                   | React                |
| Store value   | No                    | You                  |


Layman Final Summary
------------------------
 useRef() gives you an empty box.
 If you attach it using ref={box}, React puts DOM element inside it.
 If you don’t attach it, you can store anything inside manually.
 React does NOT choose element automatically.
 You tell React which element to store by attaching ref attribute.

Interview One-Liner
--------------------
 useRef creates a mutable object. If passed to the ref attribute, React assigns the DOM element to its current property. 
 Otherwise, it behaves like a persistent variable across renders.

