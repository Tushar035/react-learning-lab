
ğŸ§  1ï¸âƒ£ What is Authentication? (Very Simple)

Authentication = Checking who the user is.

Example:

You enter email + password

Server checks database

If correct â†’ you are logged in


Thatâ€™s authentication.


---

ğŸ§  2ï¸âƒ£ What is JWT?

JWT = JSON Web Token

It is a string like this:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

This token contains:

User ID

Email

Role (Admin/User)

Expiry time


Server creates it. Frontend stores it. Frontend sends it with every request.


---

ğŸ§  3ï¸âƒ£ Access Token vs Refresh Token

ğŸ”¹ Access Token

Short life (15 minutes)

Used to access protected APIs

Sent in every request


ğŸ”¹ Refresh Token

Long life (7 days)

Used to generate new access token

Not used for normal API calls



---

ğŸ— Big Picture Flow

1. User logs in


2. Server sends:

accessToken

refreshToken

user data



3. Frontend stores them


4. User accesses dashboard


5. If access token expires:

Use refresh token

Get new access token



6. User logs out â†’ tokens removed




---

ğŸ— Frontend Project Structure

src/
 â”œâ”€â”€ api/
 â”‚     apiClient.js
 â”œâ”€â”€ context/
 â”‚     AuthContext.js
 â”‚     AuthProvider.js
 â”œâ”€â”€ components/
 â”‚     ProtectedRoute.jsx
 â”‚     RoleProtectedRoute.jsx
 â”œâ”€â”€ pages/
 â”‚     Login.jsx
 â”‚     Register.jsx
 â”‚     Dashboard.jsx
 â”‚     VerifyEmail.jsx
 â”‚     ForgotPassword.jsx
 â”‚     ResetPassword.jsx
 â”œâ”€â”€ App.jsx
 â””â”€â”€ main.jsx


---

ğŸ”¥ STEP 1: Setup Axios (API Client)

ğŸ“ api/apiClient.js

import axios from "axios";

const api = axios.create({
  baseURL: "https://your-backend.com/api",
  withCredentials: true, // important for cookies
  timeout: 10000
});

export default api;

Why this file?

Instead of writing full URL everywhere, we create one central API client.


---

ğŸ”¥ STEP 2: Create Global Auth Context

ğŸ“ context/AuthContext.js

import { createContext } from "react";

export const AuthContext = createContext();

This creates global storage for user.


---

ğŸ”¥ STEP 3: Create Auth Provider

ğŸ“ context/AuthProvider.js

import { useState, useEffect } from "react";
import { AuthContext } from "./AuthContext";
import api from "../api/apiClient";

export const AuthProvider = ({ children }) => {

  const [user, setUser] = useState(null);

  // Check if user already logged in (after refresh)
  useEffect(() => {
    api.get("/me")
      .then(res => setUser(res.data))
      .catch(() => setUser(null));
  }, []);

  const login = async (email, password) => {
    await api.post("/login", { email, password });
    const response = await api.get("/me");
    setUser(response.data);
  };

  const register = async (data) => {
    await api.post("/register", data);
  };

  const logout = async () => {
    await api.post("/logout");
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, register, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

What is happening here?

user = logged in user

login() = call backend login

logout() = clear user

useEffect = check login when page refreshes



---

ğŸ”¥ STEP 4: Wrap Your App

In main.jsx:

<AuthProvider>
  <App />
</AuthProvider>

Now every component can access user.


---

ğŸ”¥ STEP 5: Login Page

const Login = () => {
  const { login } = useContext(AuthContext);

  const handleSubmit = async (e) => {
    e.preventDefault();
    await login(email, password);
  };
};

Very simple:

Call login()

Backend sets cookie

user state updates



---

ğŸ” STEP 6: Protected Routes

We donâ€™t want non-logged users to access dashboard.

const ProtectedRoute = ({ children }) => {
  const { user } = useContext(AuthContext);

  if (!user) return <Navigate to="/login" />;

  return children;
};


---

ğŸ” STEP 7: Refresh Token System (Important)

Problem: Access token expires after 15 minutes.

Solution: Automatically refresh token.


---

ğŸ”¹ Axios Refresh Logic

api.interceptors.response.use(
  response => response,
  async error => {
    if (error.response?.status === 401) {
      try {
        await api.post("/refresh");
        return api(error.config);
      } catch {
        window.location.href = "/login";
      }
    }
    return Promise.reject(error);
  }
);

What this does?

If API returns 401:

Call refresh endpoint

Retry original request

If refresh fails â†’ logout



---

ğŸ‘® STEP 8: Role-Based Authorization

Backend adds role in token:

Admin or User.


---

ğŸ”¹ Protect Admin Route

const RoleProtectedRoute = ({ allowedRoles, children }) => {
  const { user } = useContext(AuthContext);

  if (!allowedRoles.includes(user.role)) {
    return <h2>Access Denied</h2>;
  }

  return children;
};

Usage:

<RoleProtectedRoute allowedRoles={["Admin"]}>
  <AdminPanel />
</RoleProtectedRoute>


---

ğŸ“§ STEP 9: Email Verification

Flow:

1. User registers


2. Backend sends email with link


3. User clicks link


4. Account activated



Frontend:

const VerifyEmail = () => {
  const token = useSearchParams().get("token");

  useEffect(() => {
    api.post("/verify-email", { token });
  }, []);
};


---

ğŸ”‘ STEP 10: Password Reset

Flow:

1. Click "Forgot Password"


2. Backend sends reset link


3. User enters new password



Frontend:

const ResetPassword = () => {
  const token = useSearchParams().get("token");

  const handleReset = async () => {
    await api.post("/reset-password", {
      token,
      newPassword: password
    });
  };
};


---

ğŸª STEP 11: Secure Cookie Authentication (Best Practice)

Instead of saving token in localStorage:

Backend stores token in httpOnly cookie.

Benefits:

JavaScript cannot access token

More secure

Prevents XSS attacks


Frontend just uses:

const api = axios.create({
  baseURL: "...",
  withCredentials: true
});

Token automatically sent in request.


---

ğŸ” Security Best Practices (Very Important)

Use HTTPS always

Access token short expiry

Refresh token stored securely

Password hashed (bcrypt)

Validate roles in backend

Rate limit login

Protect against brute force



---

ğŸ¯ What You Learned

You now understand:

Authentication basics

JWT tokens

Access vs Refresh token

Login system

Protected routes

Role-based authorization

Email verification

Password reset

Secure cookie authentication

Refresh token system



ğŸ§  1ï¸âƒ£ Complete Login Flow (Basic JWT Flow)

ğŸ”¹ Step-by-Step Flow

User (Browser)
   â”‚
   â”‚ 1ï¸âƒ£ Enter Email + Password
   â–¼
React Frontend
   â”‚
   â”‚ 2ï¸âƒ£ POST /login
   â–¼
Backend Server
   â”‚
   â”‚ 3ï¸âƒ£ Validate credentials (DB check)
   â”‚
   â”‚ 4ï¸âƒ£ Generate Access Token (15 min)
   â”‚ 5ï¸âƒ£ Generate Refresh Token (7 days)
   â–¼
Response sent back
   â”‚
   â”‚ 6ï¸âƒ£ Store tokens
   â–¼
User Logged In âœ…


---

ğŸ§  What is inside Access Token?

{
  userId: 101,
  email: "abc@gmail.com",
  role: "Admin",
  exp: 15min
}


---

ğŸ” 2ï¸âƒ£ Accessing Protected API

When user opens Dashboard:

User clicks Dashboard
   â”‚
   â–¼
React sends GET /dashboard
   â”‚
   â”‚ Authorization: Bearer accessToken
   â–¼
Backend verifies token
   â”‚
   â”‚ If valid â†’ send data
   â–¼
Dashboard loads âœ…


---

â³ 3ï¸âƒ£ What Happens When Access Token Expires?

Access token expired â†’ server returns 401.

React API call
   â”‚
   â–¼
Backend
   â”‚
   â”‚ âŒ 401 Unauthorized
   â–¼
Axios Interceptor triggers
   â”‚
   â”‚ POST /refresh
   â–¼
Backend checks refresh token
   â”‚
   â”‚ If valid â†’ send new access token
   â–¼
Axios retries original request
   â–¼
User doesnâ€™t notice anything âœ…


---

ğŸ”„ 4ï¸âƒ£ Refresh Token Flow Diagram

Access Token Expired
        â”‚
        â–¼
Frontend receives 401
        â”‚
        â–¼
Call /refresh endpoint
        â”‚
        â–¼
Backend validates refresh token
        â”‚
        â”œâ”€â”€ Valid â†’ Generate new access token
        â”‚            Send back to frontend
        â”‚
        â””â”€â”€ Invalid â†’ Force logout


---

ğŸšª 5ï¸âƒ£ Logout Flow

User clicks Logout
   â”‚
   â–¼
Frontend clears:
   - Access Token
   - Refresh Token
   - User state
   â–¼
User redirected to Login

If using cookies:

Backend clears cookie


---

ğŸ‘® 6ï¸âƒ£ Role-Based Authorization Flow

Letâ€™s say:

Admin â†’ can access /admin

User â†’ cannot access /admin



---

ğŸ”¹ How It Works

Access Token contains:
{
  role: "Admin"
}


---

Frontend Check

React checks user.role
   â”‚
   â”œâ”€â”€ If Admin â†’ show Admin Panel
   â””â”€â”€ If User â†’ show Access Denied


---

Backend Check (Very Important)

API: GET /admin-data
   â”‚
Backend checks:
   â”‚
   If role != Admin â†’ return 403

Frontend check = UI safety
Backend check = real security


---

ğŸ“§ 7ï¸âƒ£ Email Verification Flow Diagram

When user registers:

User registers
   â”‚
   â–¼
Backend creates verification token
   â”‚
   â–¼
Backend sends email:
https://app.com/verify?token=abc123
   â”‚
   â–¼
User clicks link
   â”‚
   â–¼
Frontend reads token
   â”‚
   â–¼
POST /verify-email
   â”‚
   â–¼
Backend marks account as verified


---

Why is this important?

Prevents:

Fake emails

Spam accounts

Bot accounts



---

ğŸ”‘ 8ï¸âƒ£ Password Reset Flow Diagram

When user forgets password:

User clicks "Forgot Password"
   â”‚
   â–¼
Enter email
   â”‚
   â–¼
Backend generates reset token
   â”‚
   â–¼
Send email:
https://app.com/reset?token=xyz
   â”‚
   â–¼
User clicks link
   â”‚
   â–¼
Frontend shows new password form
   â”‚
   â–¼
POST /reset-password
   â”‚
   â–¼
Backend updates password


---

ğŸª 9ï¸âƒ£ Cookie vs LocalStorage Flow (Very Important)


---

âŒ localStorage Flow

Login
   â”‚
   â–¼
Store token in localStorage
   â”‚
   â–¼
Attach token manually in header

Problem: If XSS attack happens â†’ token stolen.


---

âœ… httpOnly Cookie Flow (Best Practice)

Login
   â”‚
   â–¼
Backend sets httpOnly cookie
   â”‚
   â–¼
Browser automatically sends cookie
   â”‚
   â–¼
JavaScript cannot access token

More secure.


---

ğŸ— 10ï¸âƒ£ Full Enterprise-Level Auth Flow (Combined)

User Login
   â”‚
   â–¼
Backend Generates:
   - Access Token (Short)
   - Refresh Token (Long)
   â”‚
   â–¼
Access Protected API
   â”‚
   â–¼
Access Token Valid?
   â”‚
   â”œâ”€â”€ Yes â†’ Return Data
   â”‚
   â””â”€â”€ No â†’ 401
              â”‚
              â–¼
        Call Refresh Endpoint
              â”‚
              â”œâ”€â”€ Refresh Valid â†’ New Access Token
              â”‚                    Retry Request
              â”‚
              â””â”€â”€ Refresh Invalid â†’ Logout


---

ğŸ§  11ï¸âƒ£ How Big Companies Do It

Large systems:

Use OAuth (Google Login)

Use Identity Server

Use Redis for refresh tokens

Use httpOnly cookies

Use rotating refresh tokens

Use CSRF protection

Monitor login attempts



---

ğŸ¯ Final Mental Model

Think like this:

Access Token = Temporary ID Card
Refresh Token = Ability to get new ID Card
Role = Permission level
Email verification = Confirm identity
Password reset = Recovery system
Cookie auth = Secure storage


---

ğŸš€ What You Now Understand

You now clearly understand:

Login flow

Token flow

Refresh flow

Role-based access

Email verification

Password reset

Cookie authentication

Security reasoning

Enterprise architecture thinking



ğŸ§  1ï¸âƒ£ What is OAuth? (Simple Explanation)

OAuth is a system that allows users to:

> Login using another platform (Google, GitHub, Facebook)



Instead of creating password manually.

Example:

You click "Login with Google"

Google verifies you
Google tells your app:
"Yes, this is the real user"


---

ğŸ§  2ï¸âƒ£ Why OAuth is Useful?

Without OAuth:

You must store passwords

You must hash passwords

You must handle reset passwords


With OAuth:

Google handles password security

You just receive verified user info



---

ğŸ— 3ï¸âƒ£ Complete OAuth Flow (Big Picture Diagram)

User clicks "Login with Google"
        â”‚
        â–¼
Frontend redirects to Google
        â”‚
        â–¼
Google Login Page
        â”‚
User enters Google credentials
        â”‚
        â–¼
Google redirects back to backend
        â”‚
        â–¼
Backend verifies Google response
        â”‚
        â–¼
Backend creates its own JWT token
        â”‚
        â–¼
Frontend receives JWT
        â”‚
        â–¼
User logged into your app âœ…

Important: Google does NOT log user into your system directly.

Your backend creates its own token.


---

ğŸ”‘ 4ï¸âƒ£ OAuth Terminology (Very Important)

Term	Meaning

Client ID	Your appâ€™s ID registered in Google
Client Secret	Secret key for backend
Redirect URI	Where Google sends user after login
Authorization Code	Temporary code from Google
Access Token (Google)	Token to access Google API
JWT (Your App)	Your own authentication token



---

ğŸ”¥ 5ï¸âƒ£ Google OAuth Flow (Detailed Diagram)

1ï¸âƒ£ User clicks "Login with Google"
        â”‚
2ï¸âƒ£ Frontend redirects to:
   https://accounts.google.com/o/oauth2/v2/auth
        â”‚
3ï¸âƒ£ User logs in on Google
        â”‚
4ï¸âƒ£ Google redirects to:
   https://your-backend.com/auth/google/callback?code=abc123
        â”‚
5ï¸âƒ£ Backend exchanges code for Google token
        â”‚
6ï¸âƒ£ Backend gets user info from Google
        â”‚
7ï¸âƒ£ Backend creates its own JWT
        â”‚
8ï¸âƒ£ JWT sent to frontend
        â”‚
9ï¸âƒ£ User logged into your system


---

ğŸ— 6ï¸âƒ£ Backend Setup (ASP.NET Core Example)

First install:

dotnet add package Microsoft.AspNetCore.Authentication.Google


---

Configure in Program.cs

builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
})
.AddCookie()
.AddGoogle(options =>
{
    options.ClientId = "YOUR_GOOGLE_CLIENT_ID";
    options.ClientSecret = "YOUR_GOOGLE_CLIENT_SECRET";
});


---

Create Login Endpoint

[HttpGet("google-login")]
public IActionResult GoogleLogin()
{
    var properties = new AuthenticationProperties
    {
        RedirectUri = Url.Action("GoogleResponse")
    };

    return Challenge(properties, GoogleDefaults.AuthenticationScheme);
}


---

Callback Endpoint

[HttpGet("google-response")]
public async Task<IActionResult> GoogleResponse()
{
    var result = await HttpContext.AuthenticateAsync();

    var email = result.Principal.FindFirst(ClaimTypes.Email)?.Value;

    // Create your own JWT here
    var token = GenerateJwt(email);

    return Ok(new { token });
}


---

âš›ï¸ 7ï¸âƒ£ React Frontend (Simple Version)

Create button:

const handleGoogleLogin = () => {
  window.location.href = "https://your-backend.com/auth/google-login";
};

Thatâ€™s it.

Backend handles everything.


---

ğŸ” 8ï¸âƒ£ After Google Login â†’ What Happens?

Google verifies user.

Backend:

Creates user in DB (if new)

Generates JWT (your app token)

Sends JWT to frontend


Frontend:

Stores JWT

Sets global user

Redirects to dashboard



---

ğŸ™ 9ï¸âƒ£ GitHub OAuth Flow (Same Concept)

GitHub works exactly same.


---

GitHub Flow Diagram

User clicks "Login with GitHub"
        â”‚
Redirect to github.com/login/oauth/authorize
        â”‚
User logs in
        â”‚
GitHub sends code to backend
        â”‚
Backend exchanges code for GitHub token
        â”‚
Backend fetches user info
        â”‚
Backend creates JWT
        â”‚
Frontend logged in


---

ASP.NET Core GitHub Setup

Install:

dotnet add package AspNet.Security.OAuth.GitHub

Configure:

.AddGitHub(options =>
{
    options.ClientId = "GITHUB_CLIENT_ID";
    options.ClientSecret = "GITHUB_CLIENT_SECRET";
});


---

ğŸ”’ 10ï¸âƒ£ Important Security Concepts

âœ” Always validate OAuth response in backend
âœ” Never trust frontend
âœ” Use HTTPS
âœ” Store JWT securely (prefer httpOnly cookies)
âœ” Protect against CSRF
âœ” Validate redirect URI


---

ğŸ¢ 11ï¸âƒ£ Production Architecture (OAuth + JWT Combined)

User clicks Google Login
        â”‚
Frontend redirects to backend
        â”‚
Backend redirects to Google
        â”‚
Google authenticates user
        â”‚
Google returns code to backend
        â”‚
Backend verifies code
        â”‚
Backend creates JWT (your app token)
        â”‚
JWT stored in cookie
        â”‚
User logged into your system


---

ğŸ§  Why Backend Must Create JWT?

Because:

Google token â‰  Your app token

Google token:

Only valid for Google API


Your JWT:

Valid for your backend

Contains your roles

Contains your permissions



---

ğŸ¯ What You Learned

You now understand:

What OAuth is

How Google login works

How GitHub login works

How backend handles OAuth

Why we create our own JWT

How React integrates with OAuth

Security best practices






 