ğŸ”´ Error Handling & Stability in React (ğŸ”¥ Must-Know Guide)
--------------------------------------------------------------
If you want to move toward Senior / Tech Lead level, error handling is not optional.
Most developers know how to fetch data. Very few know how to handle failure gracefully.

1. Try/Catch in React
------------------------
ğŸ”¹ Why Try/Catch is Needed
-----------------------------
React itself does not automatically catch:
Async errors
API failures
Promise rejections

You must handle them manually.

ğŸ”¹ Basic Example (API Call)
----------------------------
const [data, setData] = useState(null);
const [error, setError] = useState(null);

const fetchData = async () => {
  try {
    const response = await fetch("/api/users");

    if (!response.ok) {
      throw new Error("Failed to fetch users");
    }

    const result = await response.json();
    setData(result);
  } catch (err) {
    setError(err.message);
  }
};

ğŸ” Whatâ€™s happening?
--------------------
try â†’ Executes risky code
catch â†’ Handles failure
Prevents app crash
Allows controlled UI feedback

ğŸ”¥ Important Rule
------------------
Try/Catch works for:
Async functions
Awaited promises

It does NOT catch:
Errors in render
Errors in lifecycle
Errors in event callbacks automatically

Thatâ€™s where other strategies come in.

2. Error Handling in Event Handlers
------------------------------------
Event handlers can throw runtime errors.

Example:
-------
const handleClick = () => {
  try {
    const result = riskyFunction();
    console.log(result);
  } catch (error) {
    console.error("Something went wrong:", error.message);
  }
};

ğŸ”¹ Async Event Handler Example
-------------------------------
const handleSubmit = async () => {
  try {
    await api.post("/login", formData);
    alert("Login successful");
  } catch (error) {
    setError("Login failed. Please try again.");
  }
};

ğŸ” Why Important?
-----------------
Without try/catch:
Unhandled Promise rejection
Console error
No UI feedback
Bad UX

3. Error Handling in useEffect
---------------------------------
useEffect cannot directly use async callback.

âŒ Wrong:
------------
useEffect(async () => {
  await fetchData();
}, []);

âœ… Correct Pattern
---------------------
useEffect(() => {
  const fetchData = async () => {
    try {
      const response = await fetch("/api/users");

      if (!response.ok) {
        throw new Error("API failed");
      }

      const data = await response.json();
      setUsers(data);
    } catch (error) {
      setError(error.message);
    }
  };

  fetchData();
}, []);

ğŸ”¥ Why This Matters
------------------------
If you donâ€™t handle errors inside useEffect:
Component breaks silently
State remains inconsistent
Debugging becomes hard

4. Global Error Handling Strategy
----------------------------------
At scale, you cannot handle errors in every component separately.
You need:
âœ” Centralized API client
âœ” Global interceptor
âœ” Global error UI
âœ” Logging system

ğŸ”¹ Example: Centralized API Wrapper
------------------------------------
// apiClient.js
import axios from "axios";

const api = axios.create({
  baseURL: "https://api.myapp.com"
});

api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      window.location.href = "/login";
    }

    return Promise.reject(error);
  }
);

export default api;
-------------------
ğŸ” Why?
Automatically handle 401
Handle 500 globally
No repeated code
Cleaner UI components

5. Error Boundaries
--------------------
ğŸ”¥ What is an Error Boundary?
A React component that catches:
Render errors
Lifecycle errors
Constructor errors

It prevents the whole app from crashing.

ğŸ”¹ Create Error Boundary
-------------------------
import React from "react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Error caught:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Something went wrong.</h2>;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

ğŸ”¹ Use It
------------
<ErrorBoundary>
  <App />
</ErrorBoundary>

âš  Important Limitation
------------------------
Error Boundaries DO NOT catch:
Async errors
Event handler errors
setTimeout errors

They only catch render-related errors.

6. Fallback UI Patterns
--------------------------
Never show blank screen.

ğŸ”¹ Pattern 1: Simple Fallback
--------------------------------
if (error) {
  return <p>Something went wrong. Please refresh.</p>;
}

ğŸ”¹ Pattern 2: Retry Button
---------------------------
{error && (
  <div>
    <p>{error}</p>
    <button onClick={fetchData}>Retry</button>
  </div>
)}

ğŸ”¹ Pattern 3: Skeleton + Graceful Degradation
-----------------------------------------------
Show cached data
Show partial content
Disable broken feature


ğŸ”¥ Professional UX Strategy
------------------------------
Instead of:
------------
âŒ "Internal Server Error"

Use:
----
âœ” "Weâ€™re having trouble loading your data."
âœ” Provide Retry
âœ” Provide Support Contact


7. Error Logging & Monitoring
-------------------------------
In production, console.log is useless.
You need monitoring tools.

ğŸ”¹ Basic Logging
--------------------
componentDidCatch(error, info) {
  console.error(error, info);
}

ğŸ”¹ Send to Server
-------------------
const logError = async (error) => {
  await fetch("/api/log-error", {
    method: "POST",
    body: JSON.stringify({ error: error.message }),
    headers: { "Content-Type": "application/json" }
  });
};

ğŸ”¥ What to Log?
------------------
âœ” Error message
âœ” Stack trace
âœ” User ID
âœ” Browser info
âœ” Route
âœ” Timestamp

ğŸ”¹ Production Monitoring Tools
--------------------------------
Sentry
LogRocket
Datadog
New Relic

They help you:
Track crashes
Replay sessions
Detect spikes
Monitor stability

ğŸ— Production Architecture for Stability
------------------------------------------
Recommended structure:
---------------------
/api
  apiClient.js
/hooks
  useApi.js
/components
  ErrorBoundary.jsx
/utils
  logger.js

ğŸ§  Stability Mindset (Senior-Level Thinking)
------------------------------------------
A junior developer asks:
-----------------------
> "How do I fetch data?"

A senior developer asks:
---------------------------
> "What happens if API fails?"
"What happens if user loses internet?"
"What happens if server returns corrupted data?"
"How do we detect production crashes?"

Thatâ€™s the difference.