1. What is Routing?
-----------------------
Routing is the mechanism that determines:
> â€œWhich component should render when a user visits a specific URL?â€

In traditional websites:
------------------------
Every URL loads a new HTML page (Server-side rendering)

In React SPA:
-------------
The app loads once
JavaScript changes the view dynamically
No full page refresh

This is called Client-Side Routing.

2. Client-Side vs Server-Side Routing
----------------------------------------
 __________________________________________________________________
 | Feature	       |      Server-Side	  |   Client-Side (React)   | 
 |________________________________________________________________|
 | Page Reload     |     	Yes	          |      No                 | 
 | Speed           |   	Slower          |     	Faster            | 
 | User Experience |  Traditional	      |     Smooth              | 
 | Technology	     | Backend Framework  |	    React Router        |  
 |_________________|____________________|_________________________| 
React uses HTML5 History API to change the URL without refreshing the page.

3. React Router Library
-------------------------
We use:
 react-router-dom
 -----------------
  It provides:

BrowserRouter - Wraps your app and enables routing using the browserâ€™s URL system.
Routes - A container that holds all your route definitions and matches the current URL to a route.
Route - Defines which component should render for a specific URL path.
Link - Creates navigation links that change the URL without reloading the page.
NavLink - Works like Link but automatically adds an active state when the route matches.
useNavigate - Works like Link but automatically adds an active state when the route matches.
useParams - Programmatically changes the route (e.g., redirect after login).
useSearchParams - Extracts dynamic URL parameters (like /users/:id).
Outlet - Renders child routes inside a parent layout.
Navigate - Redirects the user to another route automatically.

4. Installation
-------------------
npm install react-router-dom

For Vite:
npm create vite@latest
npm install react-router-dom

5. Basic Routing Setup
--------------------------
To enable routing:
1. Wrap your app with BrowserRouter in main.jsx
2. Define routes using Routes  in app.jsx
3. Map paths using Route in app.jsx

Step 1: Wrap App with BrowserRouter
-----------------------------------
// main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { BrowserRouter } from "react-router-dom";

ReactDOM.createRoot(document.getElementById("root")).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);

BrowserRouter listens to URL changes.
It uses the browserâ€™s history stack. (history api)
It makes routing available in the app.

Step 2: Define Routes
---------------------
// App.jsx
import { Routes, Route } from "react-router-dom";
import Home from "./pages/Home";
import About from "./pages/About";

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/about" element={<About />} />
    </Routes>
  );
}

export default App;

Routes replaces Switch (v6)
Route attributes defines:
path â†’ URL
element â†’ Component to render

6. Navigation in React Router
------------------------------
Link (Declarative Navigation)
------------------------------
Link works like <a> but:
Does NOT reload page
Uses internal navigation

import { Link } from "react-router-dom";

function Navbar() {
  return (
    <nav>
      <Link to="/">Home</Link>
      <Link to="/about">About</Link>
    </nav>
  );
}

NavLink (Active Styling)
---------
Used when you want to:
Highlight active route
Show current page in navbar

import { NavLink } from "react-router-dom";

<NavLink
  to="/about"
  className={({ isActive }) =>
    isActive ? "active-link" : ""
  }
>
  About
</NavLink>


7. Dynamic Routing (URL Parameters)
-----------------------------------
Sometimes URLs contain dynamic values:

/products/101
Here 101 is dynamic.

 Define Route
<Route path="/products/:id" element={<ProductDetails />} />

:id is called a URL parameter.

Access Parameter

import { useParams } from "react-router-dom";

function ProductDetails() {
  const { id } = useParams();

  return <h2>Product ID: {id}</h2>;
}

useParams() -  extracts dynamic values from URL.
----------
Useful for API calls.

 8. Programmatic Navigation
----------------------------
Sometimes navigation happens after:
Login
Form submission
API success

Use useNavigate.
ğŸ”¹ Example

import { useNavigate } from "react-router-dom";

function Login() {
  const navigate = useNavigate();

  const handleLogin = () => {
    navigate("/dashboard");
  };

  return <button onClick={handleLogin}>Login</button>;
}


9. Nested Routing
-----------------
Used when:
A route contains child routes
Example: Dashboard

/dashboard
/dashboard/profile
/dashboard/settings

ğŸ”¹ Define Nested Routes
<Route path="/dashboard" element={<Dashboard />}>
  <Route path="profile" element={<Profile />} />
  <Route path="settings" element={<Settings />} />
</Route>

ğŸ”¹ Dashboard Component
import { Outlet, Link } from "react-router-dom";

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Link to="profile">Profile</Link>
      <Link to="settings">Settings</Link>

      <Outlet />
    </div>
  );
}

Outlet renders child route
Without Outlet â†’ children wonâ€™t render

10. Layout Routes (Shared UI)
------------------------------
Common UI elements:
Header
Sidebar
Footer

Instead of repeating, use Layout route.
Route Setup

<Route path="/" element={<Layout />}>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />
</Route>

ğŸ”¹ Layout Component
--------------------
import { Outlet } from "react-router-dom";

function Layout() {
  return (
    <>
      <header>Header</header>
      <Outlet />
      <footer>Footer</footer>
    </>
  );
}

11. Protected Routes (Authentication)
----------------------------------
Restrict access to certain routes.
Example:

/dashboard â†’ Only logged-in users

ğŸ”¹ ProtectedRoute Component
-----------------------------
import { Navigate } from "react-router-dom";

function ProtectedRoute({ children }) {
  const isAuthenticated = false;

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return children;
}

ğŸ”¹ Usage
-----------
<Route
  path="/dashboard"
  element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  }
/>

12. Query Parameters
--------------------
Example:
/search?q=react

 Code

import { useSearchParams } from "react-router-dom";

function Search() {
  const [searchParams] = useSearchParams();
  const query = searchParams.get("q");

  return <h2>Search: {query}</h2>;
}

 13. 404 Not Found
-------------------
<Route path="*" element={<NotFound />} />

* matches any unmatched route.

 14. Lazy Loading (Performance Optimization)
-------------------------------
Load component only when needed.
Improves:
Initial load time
Performance

ğŸ”¹ Code
---------
import React, { Suspense, lazy } from "react";

const Dashboard = lazy(() => import("./Dashboard"));

<Route
  path="/dashboard"
  element={
    <Suspense fallback={<h2>Loading...</h2>}>
      <Dashboard />
    </Suspense>
  }
/>

15. Scalable Folder Structure
-------------------------------
For large projects:

src/
â”‚
â”œâ”€â”€ app/
â”‚   â””â”€â”€ router.jsx
â”‚
â”œâ”€â”€ layouts/
â”œâ”€â”€ pages/
â”œâ”€â”€ features/
â”œâ”€â”€ routes/
â””â”€â”€ main.jsx

16. How React Router Works Internally (Deep )
-------------------------------------
1. BrowserRouter listens to URL changes.
2. When URL changes:
It checks matching Route.
3. Matching routeâ€™s component renders.
4. DOM updates without reload.

It uses:
History API
Context API
React reconciliation

17. Best Practices
------------------
Centralize route definitions
Use layout routes
Protect sensitive routes
Always add 404
Use lazy loading
Avoid deeply nested routes
Separate route logic from UI

Final Summary
--------------
React Routing allows you to:
Build multi-page experience in SPA
Create nested layouts
Handle dynamic URLs
Protect routes
Optimize performance
Scale enterprise applications

1. âœ… Protected Routes (Auth Guards)
2. âœ… Role-Based Authorization
3. âœ… Navigation Patterns (redirect, replace, back, state)

Weâ€™ll use React Router v6+ and explain both  + implementation for each concept.

1ï¸âƒ£ Protected Routes (Auth Guards)
----------------------------------------
What is a Protected Route?
A Protected Route restricts access to a page unless certain conditions are met â€” typically:

User must be logged in
Token must be valid
Session must not be expired

Example:
Route	Access
/login    	Public
/dashboard	Logged-in users only
/profile  	Logged-in users only

Why Do We Need Protected Routes?
--------------------------------
Without protection:
----------------------
Users can manually type /dashboard in the browser.
Anyone can access restricted content.
Application security is compromised.

Protected Routes ensure:
Only authenticated users can view private pages.
Unauthenticated users are redirected.

Important Concept:
React Router does NOT provide built-in authentication.

We must:
1. Store auth state (context / Redux)
2. Wrap private routes
3. Redirect unauthorized users

ğŸ§  Implementation
------------------------------
Step 1ï¸âƒ£ Create Authentication Context
------------------------------------
We need a global auth state.

// context/AuthContext.jsx
----------------------------
import { createContext, useContext, useState } from "react";

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);  --> global auth state

  const login = () => {
    setUser({ name: "Tushar", role: "user" });  --> setting user
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);

Step 2ï¸âƒ£ Create Protected Route Component
-----------------------------------------
// components/ProtectedRoute.jsx
import { Navigate } from "react-router-dom";
import { useAuth } from "../context/AuthContext";

const ProtectedRoute = ({ children }) => {
  const { user } = useAuth();

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return children;
};

export default ProtectedRoute;

Why replace?
------------
<Navigate to="/login" replace />

replace prevents:
User pressing back
Returning to restricted page

It replaces history instead of pushing new entry.

Step 3ï¸âƒ£ Use Protected Route in App
------------------------------------
// App.jsx
----------
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { AuthProvider } from "./context/AuthContext";
import ProtectedRoute from "./components/ProtectedRoute";
import Dashboard from "./pages/Dashboard";
import Login from "./pages/Login";

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route
            path="/dashboard"
            element={
              <ProtectedRoute>
                <Dashboard />
              </ProtectedRoute>
            }
          />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;

2ï¸âƒ£ Role-Based Authorization
----------------------------
Authentication vs Authorization

Concept	Meaning
Authentication	Who are you?
Authorization	  What can you access?

Example:
User is logged in âœ…
But only Admin can access /admin
Thatâ€™s authorization.

Real-World Example
-------------------
In an enterprise system:
Role	Access
User	Dashboard
Manager	Reports
Admin	All features

ğŸ§  Implementation
------------------
Step 1ï¸âƒ£ Update Auth Context with Role
--------------------------------------
const login = () => {
  setUser({
    name: "Tushar",
    role: "admin", // change role here
  });
};

Step 2ï¸âƒ£ Create Role-Based Guard
---------------------------------
// components/RoleProtectedRoute.jsx
import { Navigate } from "react-router-dom";
import { useAuth } from "../context/AuthContext";

const RoleProtectedRoute = ({ children, allowedRoles }) => {
  const { user } = useAuth();

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  if (!allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" replace />;
  }

  return children;
};

export default RoleProtectedRoute;

Step 3ï¸âƒ£ Apply Role Protection
----------------------------
<Route
  path="/admin"
  element={
    <RoleProtectedRoute allowedRoles={["admin"]}>
      <AdminPage />
    </RoleProtectedRoute>
  }
/>

Unauthorized Page
------------------
const Unauthorized = () => {
  return <h2>You are not authorized to view this page.</h2>;
};

âš  Important
-------------
Frontend role checks are NOT secure alone.
Always validate roles in backend API.

3ï¸âƒ£ Navigation Patterns in React Router
-----------------------------------------
Navigation means programmatically changing routes.

React Router provides:
Method	Purpose
----------------
navigate("/path")	Redirect
navigate(-1)	Go back
replace: true	Replace history
state	Pass data

ğŸ§  useNavigate Hook
---------------------
import { useNavigate } from "react-router-dom";

const Login = () => {
  const navigate = useNavigate();
  const { login } = useAuth();

  const handleLogin = () => {
    login();
    navigate("/dashboard");
  };

  return <button onClick={handleLogin}>Login</button>;
};


ğŸ” Replace Navigation
---------------------
navigate("/dashboard", { replace: true });

Use this after login or logout.

ğŸ”™ Navigate Back
----------------
navigate(-1);

Go back one step.

ğŸ“¦ Passing Data Between Routes
-------------------------------
Send Data
---------
navigate("/dashboard", {
  state: { fromLogin: true }
});

Receive Data
-------------
import { useLocation } from "react-router-dom";

const Dashboard = () => {
  const location = useLocation();
  console.log(location.state);
};


4ï¸âƒ£ Advanced: Redirect User to Originally Requested Page
-----------------------------------------------------------
If user tries:
/admin â†’ But not logged in â†’ Redirect to login â†’ After login â†’ Return to /admin
Implementation
Step 1: Save Attempted Route
----------------------------
import { useLocation, Navigate } from "react-router-dom";

const ProtectedRoute = ({ children }) => {
  const { user } = useAuth();
  const location = useLocation();

  if (!user) {
    return (
      <Navigate
        to="/login"
        state={{ from: location }}
        replace
      />
    );
  }

  return children;
};

Step 2: Redirect After Login
-----------------------------
const location = useLocation();
const navigate = useNavigate();

const from = location.state?.from?.pathname || "/dashboard";
login();
navigate(from, { replace: true });
Now user returns to requested page.

ğŸ— Recommended Folder Structure
---------------------------------
src/
 â”œâ”€â”€ components/
 â”‚    â”œâ”€â”€ ProtectedRoute.jsx
 â”‚    â”œâ”€â”€ RoleProtectedRoute.jsx
 â”œâ”€â”€ context/
 â”‚    â””â”€â”€ AuthContext.jsx
 â”œâ”€â”€ pages/
 â”‚    â”œâ”€â”€ Login.jsx
 â”‚    â”œâ”€â”€ Dashboard.jsx
 â”‚    â”œâ”€â”€ Admin.jsx
 â”‚    â”œâ”€â”€ Unauthorized.jsx
 â”œâ”€â”€ App.jsx

ğŸš€ Best Practices
-------------------
âœ… Persist token in localStorage
âœ… Validate JWT on app load
âœ… Handle token expiry
âœ… Use Axios interceptors
âœ… Always secure backend

ğŸ¯ Interview Questions
---------------------------
1. What is difference between authentication and authorization?
2. Why use replace in Navigate?
3. How does React Router manage history?
4. How to prevent infinite redirects?
5. How to persist login after refresh?