ğŸŸ  Complete Guide to Data Fetching & API Handling in React
-------------------------------------------------------------
 HTTP Requests using fetch
---------------------------
ğŸ”¹ What is fetch?
-----------------
fetch() is a built-in browser API that allows you to make HTTP requests to a server.

It returns a Promise.
ğŸ”¹ Basic GET Request
---------------------
useEffect(() => {
  fetch("https://jsonplaceholder.typicode.com/posts")
    .then((response) => response.json())
    .then((data) => console.log(data))
    .catch((error) => console.error(error));
}, []);

ğŸ” Whatâ€™s happening?
---------------------
1. fetch() sends a GET request.
2. It returns a Promise.
3. response.json() converts response into JavaScript object.
4. .catch() handles network errors.

ğŸ”¹ Why response.ok Check is Important
Fetch does NOT throw error for HTTP 400 or 500.

So this is required:

const fetchPosts = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");

  if (!response.ok) {
    throw new Error("Request failed");
  }

  return response.json();
};

ğŸ”¥ Important Concept:
-----------------------
Network error â†’ fetch throws
HTTP error (404/500) â†’ fetch does NOT throw

You must check response.ok.

ğŸ”¹ POST Request Example
------------------------
const createPost = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      title: "New Post",
      body: "Content",
      userId: 1
    })
  });

  return response.json();
};

ğŸ” Explanation
----------------
method defines HTTP verb
headers tell server weâ€™re sending JSON
body must be stringified

âœ… When to Use Fetch?
-------------------------
Small apps
No need for interceptors
No advanced config needed

43ï¸âƒ£ Axios
-----------
ğŸ”¹ What is Axios?
-------------------
Axios is a popular HTTP client library for browsers and Node.js.

npm install axios

ğŸ”¹ Basic GET
--------------
import axios from "axios";

const fetchPosts = async () => {
  const response = await axios.get(
    "https://jsonplaceholder.typicode.com/posts"
  );

  console.log(response.data);
};

ğŸ” Why easier than fetch?
---------------------------
No need for .json()
Automatically parses JSON
Throws error for 4xx / 5xx

ğŸ”¹ Axios Response Structure
-----------------------------
{
  data,
  status,
  headers,
  config
}

You mostly use:
---------------
response.data

ğŸ”¹ Creating Axios Instance (Production Pattern)
------------------------------------------------
// apiClient.js
import axios from "axios";

const api = axios.create({
  baseURL: "https://api.myapp.com",
  timeout: 10000
});

export default api;
-------------------
ğŸ”¥ Why use instance?

Central config
Single place for auth
Easy maintenance

ğŸ”¹ Axios Interceptors (Very Important)
---------------------------------------
Interceptors allow you to modify requests globally.

api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");

  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }

  return config;
});

ğŸ” Why important?
--------------------
Automatically attach JWT token
Handle refresh tokens
Log requests
Global error handling

âœ… Why Axios is preferred in production
----------------------------------------
Better error handling
Timeout support
Interceptors
Cleaner syntax

44ï¸âƒ£ Async / Await Patterns
-----------------------------
Async/Await makes async code readable.

ğŸ”¹ Sequential Calls
---------------------
const loadData = async () => {
  const user = await fetchUser();
  const posts = await fetchPosts(user.id);
};

ğŸ” Explanation
-----------------
Second request waits for first.

Good when:
API 2 depends on API 1

ğŸ”¹ Parallel Calls (Better Performance)
----------------------------------------
const loadData = async () => {
  const [users, posts] = await Promise.all([
    fetchUsers(),
    fetchPosts()
  ]);
};

ğŸ”¥ Why faster?
---------------
Both requests run at same time.

ğŸ”¹ Try / Catch / Finally Pattern
---------------------------------
const fetchData = async () => {
  try {
    setLoading(true);
    const res = await api.get("/users");
    setUsers(res.data);
  } catch (error) {
    setError("Something went wrong");
  } finally {
    setLoading(false);
  }
};

ğŸ” Why finally?
------------------
Always runs. Even if error happens.
Perfect for loading state reset.

45ï¸âƒ£ Loading States (UX Critical)
---------------------------------
If you donâ€™t show loading, user thinks app is broken.

ğŸ”¹ Basic Loading State
-----------------------
const [loading, setLoading] = useState(false);

useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    try {
      const res = await api.get("/posts");
      setData(res.data);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);

ğŸ”¹ UI Handling
---------------
{loading && <p>Loading...</p>}
{!loading && data.map(post => (
  <div key={post.id}>{post.title}</div>
))}

ğŸ”¥ Advanced UX Patterns

Skeleton loaders
Disable button while submitting
Optimistic updates
Retry button

46ï¸âƒ£ API Error Handling (Production Grade)
-----------------------------------------
Never just console.log(error).

ğŸ”¹ Axios Error Types
---------------------
catch (error) {
  if (error.response) {
    // Server responded with error
  } else if (error.request) {
    // Request sent but no response
  } else {
    // Something else
  }
}

ğŸ”¹ Centralized Error Hook
--------------------------
const useApi = (apiFunction) => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const request = async (...args) => {
    setLoading(true);
    setError(null);

    try {
      const response = await apiFunction(...args);
      return response;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return { request, loading, error };
};

ğŸ”¥ Why this is powerful?
-------------------------
Reusable
Clean UI
Single error handling logic

47ï¸âƒ£ Retry, Timeout & Cancel Requests
-------------------------------------
Real-world apps must handle:
Slow network
Server crash
User navigation
Multiple clicks

ğŸ”¹ Timeout in Axios
---------------------
const api = axios.create({
  timeout: 5000
});

If server doesnâ€™t respond in 5 sec â†’ error thrown.

ğŸ”¹ Manual Retry
-----------------
const fetchWithRetry = async (retries = 3) => {
  try {
    return await api.get("/users");
  } catch (error) {
    if (retries === 0) throw error;
    return fetchWithRetry(retries - 1);
  }
};

ğŸ”¹ Exponential Backoff (Professional Pattern)
----------------------------------------------
const fetchWithBackoff = async (retries = 3, delay = 1000) => {
  try {
    return await api.get("/users");
  } catch (error) {
    if (retries === 0) throw error;

    await new Promise(res => setTimeout(res, delay));
    return fetchWithBackoff(retries - 1, delay * 2);
  }
};

ğŸ”¥ Why backoff?
--------------
Prevents:
Server overload
DDOS effect
Infinite retry loops

48ï¸âƒ£ AbortController (Cancel Requests)
----------------------------------
Important when:
Component unmounts
User types in search field
User changes route

ğŸ”¹ Example

useEffect(() => {
  const controller = new AbortController();

  const fetchData = async () => {
    try {
      const response = await fetch("/posts", {
        signal: controller.signal
      });

      const data = await response.json();
      setData(data);
    } catch (error) {
      if (error.name === "AbortError") {
        console.log("Request cancelled");
      }
    }
  };

  fetchData();

  return () => {
    controller.abort();
  };
}, []);

ğŸ” Why cleanup is important?
------------------------------
Prevents:
Memory leaks
Setting state on unmounted component
React warnings

ğŸ— Recommended Folder Structure (Tech Lead Style)
--------------------------------------------------
/api
  apiClient.js
  userApi.js
/hooks
  useApi.js
/pages
  Users.jsx

Separation Principle:

UI â‰  API logic

ğŸš€ Senior-Level Best Practices
--------------------------------
âœ” Always show loading state
âœ” Centralize API configuration
âœ” Use interceptors for auth
âœ” Retry only safe requests (GET)
âœ” Cancel unnecessary requests
âœ” Never mix API logic inside UI components
âœ” Handle 401 globally
