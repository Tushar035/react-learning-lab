# ğŸ“˜ Blog 6: `createSlice` Deep Dive

*(With Diagrams, Real Project Code, Mistakes & Edge Cases)*

> ğŸ¯ Goal: Master `createSlice` completely
> ğŸ¯ After this blog, youâ€™ll understand how Redux Toolkit removes boilerplate and how Immer works internally.

This is one of the most important blogs in the series.

---

# ğŸ§  1ï¸âƒ£ What Problem Does `createSlice` Solve?

Old Redux required:

* Action types
* Action creators
* Switch-case reducers
* Manual exports

Example (Old Way):

```js
// action types
const ADD_ITEM = "cart/addItem";

// action creator
const addItem = (item) => ({
  type: ADD_ITEM,
  payload: item
});

// reducer
function cartReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_ITEM:
      return {
        ...state,
        items: [...state.items, action.payload]
      };
    default:
      return state;
  }
}
```

Too repetitive.

Too error-prone.

---

# ğŸš€ 2ï¸âƒ£ What Is `createSlice`?

`createSlice`:

* Creates reducer
* Creates action creators
* Auto-generates action types
* Enables safe state mutation (via Immer)

All in one place.

---

# ğŸ— 3ï¸âƒ£ Basic Structure of `createSlice`

```js
import { createSlice } from "@reduxjs/toolkit";

const cartSlice = createSlice({
  name: "cart",
  initialState: {
    items: [],
    total: 0
  },
  reducers: {
    addItem: (state, action) => {
      state.items.push(action.payload);
      state.total += action.payload.price;
    }
  }
});

export const { addItem } = cartSlice.actions;
export default cartSlice.reducer;
```

Done.

No switch.
No action types.
No spread operator.

---

# ğŸ”„ 4ï¸âƒ£ How `createSlice` Works Internally

![Image](https://redux.js.org/assets/images/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2A-LI_oJ_e_DpY2mahvV1Hug.png)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2AyYkitaR24SuFNXYyTxL1xA.gif)

![Image](https://www.previousnext.com.au/sites/default/files/styles/content_1x/public/2022-08/Redux%20blog%20-%20architecture.jpg.webp?itok=UPY0ovUn)

Internally:

1ï¸âƒ£ Generates action type â†’ `"cart/addItem"`
2ï¸âƒ£ Creates action creator function
3ï¸âƒ£ Wraps reducer with **Immer**
4ï¸âƒ£ Converts mutation into immutable update

So when you write:

```js
state.items.push(item)
```

Immer does:

```js
return {
  ...state,
  items: [...state.items, item]
}
```

Automatically.

---

# ğŸ§  5ï¸âƒ£ What Is Immer Doing?

Immer creates a **draft state**.

You mutate the draft.

It produces a new immutable state behind the scenes.

Flow:

Original State
â¬‡
Immer Draft Proxy
â¬‡
You â€œmutateâ€
â¬‡
Immer produces new immutable state

Thatâ€™s why Redux Toolkit feels easier.

---

# ğŸ¢ 6ï¸âƒ£ Real Project Example â€“ Authentication System

Letâ€™s build realistic auth slice.

---

## ğŸ“ authSlice.js

```js
import { createSlice } from "@reduxjs/toolkit";

const initialState = {
  user: null,
  token: null,
  loading: false,
  error: null
};

const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    loginStart: (state) => {
      state.loading = true;
      state.error = null;
    },
    loginSuccess: (state, action) => {
      state.loading = false;
      state.user = action.payload.user;
      state.token = action.payload.token;
    },
    loginFailure: (state, action) => {
      state.loading = false;
      state.error = action.payload;
    },
    logout: (state) => {
      state.user = null;
      state.token = null;
    }
  }
});

export const {
  loginStart,
  loginSuccess,
  loginFailure,
  logout
} = authSlice.actions;

export default authSlice.reducer;
```

This is production-style slice.

---

# ğŸ”¥ 7ï¸âƒ£ Generated Action Types

RTK automatically creates:

```
auth/loginStart
auth/loginSuccess
auth/loginFailure
auth/logout
```

No manual string writing.

Prevents typo bugs.

---

# âš™ï¸ 8ï¸âƒ£ `prepare` Callback (Advanced Feature)

Sometimes you want to transform payload.

Example:

```js
addItem: {
  reducer: (state, action) => {
    state.items.push(action.payload);
  },
  prepare: (item) => {
    return {
      payload: {
        ...item,
        id: crypto.randomUUID()
      }
    };
  }
}
```

Now:

```js
dispatch(addItem({ name: "Phone", price: 20000 }))
```

Will automatically add ID.

Great for:

* Adding timestamps
* Adding unique IDs
* Formatting payload

---

# âš ï¸ 9ï¸âƒ£ Common Mistakes in `createSlice`

---

## âŒ Mistake 1: Returning New State AND Mutating

Wrong:

```js
addItem: (state, action) => {
  state.items.push(action.payload);
  return state;
}
```

Never mix both patterns.

Either:

Mutate draft

OR

Return new state

Not both.

---

## âŒ Mistake 2: Mutating Nested Non-Draft Objects

Example:

```js
state.user.profile.name = "Tushar"
```

This is fine IF profile exists in draft.

But avoid mutating external objects:

```js
const newUser = action.payload;
newUser.name = "Changed"; // âŒ modifies external object
state.user = newUser;
```

Always treat payload as immutable.

---

## âŒ Mistake 3: Overloading Slice with Too Much Logic

Bad:

* API calls inside slice
* Complex business logic
* Huge reducers

Keep slice focused on state changes.

Async logic should go in `createAsyncThunk` (next blog).

---

# ğŸ§¨ 1ï¸âƒ£0ï¸âƒ£ Edge Cases

---

## ğŸ”¥ Edge Case 1: Large Deeply Nested State

Immer handles deep nesting well.

But performance can degrade if:

* State is very large
* Deeply nested objects updated frequently

Solution:

* Normalize state
* Keep state flat

---

## ğŸ”¥ Edge Case 2: Accidentally Replacing Entire State

If you return something:

```js
return { loading: true }
```

You just removed all other fields.

Be careful when returning new object.

---

## ğŸ”¥ Edge Case 3: Name Conflicts Across Slices

Two slices:

```js
name: "cart"
name: "cart"
```

Will generate same action types.

Always keep slice names unique.

---

# ğŸ§  1ï¸âƒ£1ï¸âƒ£ Why `createSlice` Is Enterprise Friendly

Because:

* Co-locates logic
* Reduces boilerplate
* Prevents typos
* Enforces naming convention
* Encourages feature-based architecture

Folder structure becomes:

```
features/
  cart/
    cartSlice.js
    cartSelectors.js
    cartAPI.js
```

Clean separation.

---

# ğŸ¢ 1ï¸âƒ£2ï¸âƒ£ .NET Comparison (For You)

| Redux Toolkit     | .NET Equivalent                 |
| ----------------- | ------------------------------- |
| createSlice       | Feature-based service class     |
| reducers          | Business logic methods          |
| prepare           | DTO transformation              |
| auto action types | Strong naming conventions       |
| Immer             | Automatic immutability handling |

`createSlice` is like:

Auto-generated service + command handler in one file.

---

# ğŸ¯ 1ï¸âƒ£3ï¸âƒ£ Interview-Level Questions

You should answer:

* How does createSlice generate action types?
* How does Immer work internally?
* When should you return state instead of mutating?
* What is prepare callback?
* Why should slice names be unique?
* What happens if you mix mutation + return?

---

# ğŸ“Œ Blog 6 Summary

You learned:

* Why createSlice exists
* How it removes boilerplate
* How Immer enables safe mutation
* Real authentication slice example
* prepare callback
* Common mistakes
* Edge cases
* Enterprise structure thinking

Now Redux should feel powerful, clean, and modern.

