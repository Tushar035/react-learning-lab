# üìò Blog 7: `createAsyncThunk` Deep Dive

*(With Diagrams, Real Project Code, Mistakes & Edge Cases)*

> üéØ Goal: Master async state handling in Redux Toolkit
> üéØ After this blog, you‚Äôll confidently handle API calls, loading states, errors, cancellation, and edge cases.

Async logic is where most Redux beginners struggle.

Let‚Äôs make it crystal clear.

---

# üß† 1Ô∏è‚É£ Why We Need `createAsyncThunk`

In real apps, we:

* Fetch products
* Login users
* Submit orders
* Load dashboard data

Reducers must be pure.

So async logic cannot go inside reducers.

Solution:

üëâ **Redux Toolkit** provides `createAsyncThunk`.

---

# üèó 2Ô∏è‚É£ Basic Structure of `createAsyncThunk`

```js
import { createAsyncThunk } from "@reduxjs/toolkit";

export const fetchProducts = createAsyncThunk(
  "products/fetchProducts",
  async (_, thunkAPI) => {
    const response = await fetch("/api/products");
    return response.json();
  }
);
```

It automatically generates 3 action types:

```
products/fetchProducts/pending
products/fetchProducts/fulfilled
products/fetchProducts/rejected
```

---

# üîÑ 3Ô∏è‚É£ Async Flow Diagram

![Image](https://redux.js.org/assets/images/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif)

![Image](https://cdn.hashnode.com/res/hashnode/image/upload/v1673218550936/3e65038d-d355-426e-986c-eb3ee37c072b.png)

![Image](https://miro.medium.com/1%2AgzSOKTC2V-mQhAJ-fc0qIA.jpeg)

![Image](https://res.cloudinary.com/infinijith/image/upload/v1673004771/Infinijith%20Blog%20Images/Redux/Redux%20Middleware/Redux_Middleware_Flow_-_Infinijith_kfyb8q.png)

Flow:

Component
‚¨á
dispatch(fetchProducts())
‚¨á
pending action
‚¨á
API call
‚¨á
fulfilled OR rejected
‚¨á
state update

Redux Toolkit manages this lifecycle automatically.

---

# üè¢ 4Ô∏è‚É£ Real Project Example ‚Äì E-Commerce Products

---

## üìÅ productsSlice.js

```js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export const fetchProducts = createAsyncThunk(
  "products/fetchProducts",
  async (_, thunkAPI) => {
    try {
      const response = await fetch("https://fakestoreapi.com/products");
      if (!response.ok) throw new Error("Failed to fetch");
      return await response.json();
    } catch (error) {
      return thunkAPI.rejectWithValue(error.message);
    }
  }
);

const productsSlice = createSlice({
  name: "products",
  initialState: {
    items: [],
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  }
});

export default productsSlice.reducer;
```

---

# üß† 5Ô∏è‚É£ Why `extraReducers`?

Because async actions are external to slice reducers.

`extraReducers` listens to those generated lifecycle actions.

Think of it like:

Reducer reacting to external commands.

---

# üîé 6Ô∏è‚É£ Using It in Component

```js
import { useDispatch, useSelector } from "react-redux";
import { fetchProducts } from "./productsSlice";

const Products = () => {
  const dispatch = useDispatch();
  const { items, loading, error } = useSelector(state => state.products);

  useEffect(() => {
    dispatch(fetchProducts());
  }, [dispatch]);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <>
      {items.map(product => (
        <div key={product.id}>{product.title}</div>
      ))}
    </>
  );
};
```

Complete real-world async flow.

---

# ‚öôÔ∏è 7Ô∏è‚É£ What Is `thunkAPI`?

Inside payload function:

```js
async (arg, thunkAPI)
```

You get access to:

* `dispatch`
* `getState`
* `rejectWithValue`
* `fulfillWithValue`
* `signal` (for cancellation)

Example:

```js
const state = thunkAPI.getState();
```

Very powerful.

---

# üß® 8Ô∏è‚É£ Edge Case: Handling API Errors Properly

Wrong way:

```js
throw error;
```

Better way:

```js
return thunkAPI.rejectWithValue(error.message);
```

Why?

Because:

* `rejectWithValue` allows custom error payload
* Cleaner error handling
* Better DevTools debugging

---

# üß® 9Ô∏è‚É£ Edge Case: Request Cancellation

Example:

```js
export const fetchProducts = createAsyncThunk(
  "products/fetch",
  async (_, { signal }) => {
    const response = await fetch("/api/products", { signal });
    return response.json();
  }
);
```

You can abort request if component unmounts.

Important for:

* Preventing memory leaks
* Avoiding race conditions

---

# ‚ö†Ô∏è 1Ô∏è‚É£0Ô∏è‚É£ Common Mistakes

---

## ‚ùå Mistake 1: Dispatching in Render

Wrong:

```js
dispatch(fetchProducts());
```

Inside component body.

Causes infinite loop.

Always use inside `useEffect`.

---

## ‚ùå Mistake 2: Not Handling Loading State

If you ignore pending:

UI may flicker or show stale data.

Always handle:

* loading
* success
* error

---

## ‚ùå Mistake 3: Overwriting State Incorrectly

Bad:

```js
return action.payload;
```

This removes loading & error properties.

Instead:

```js
state.items = action.payload;
```

Preserve structure.

---

## ‚ùå Mistake 4: Multiple Rapid Dispatches

User clicks refresh quickly.

Two requests:

* First slow
* Second fast

Slow one finishes last ‚Üí overrides new data.

Solution:

* Track requestId
* Or cancel previous request

Advanced handling uses `thunkAPI.signal`.

---

# üß† 1Ô∏è‚É£1Ô∏è‚É£ Race Condition Awareness (Senior Level)

Example:

User searches quickly:

```
search?q=a
search?q=ap
search?q=app
```

Older request returns later.

Overrides newer results.

Solution strategies:

* AbortController
* Track requestId
* Compare with latest request

Enterprise-level awareness is important.

---

# üè¢ 1Ô∏è‚É£2Ô∏è‚É£ .NET Comparison (For You)

| Redux Async       | .NET Equivalent        |
| ----------------- | ---------------------- |
| createAsyncThunk  | Async service method   |
| pending           | Loading flag           |
| fulfilled         | Success response       |
| rejected          | Exception handling     |
| thunkAPI.getState | Access scoped services |
| signal            | CancellationToken      |

Think of `createAsyncThunk` like:

Frontend async command handler.

---

# üéØ 1Ô∏è‚É£3Ô∏è‚É£ Interview-Level Questions

You should answer:

* What actions does createAsyncThunk generate?
* Why use rejectWithValue?
* What is thunkAPI?
* How to handle cancellation?
* How to prevent race conditions?
* Why use extraReducers?

---

# üìå Blog 7 Summary

You learned:

* Why async logic cannot be in reducers
* How createAsyncThunk works
* Lifecycle: pending ‚Üí fulfilled ‚Üí rejected
* Real e-commerce API example
* Error handling best practices
* Cancellation & race condition awareness
* Common mistakes
* Enterprise-level async thinking

Now you understand async Redux deeply.

