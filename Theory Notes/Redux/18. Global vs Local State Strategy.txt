# ğŸ“˜ Blog 18: Testing Redux (Unit + Integration + Middleware + RTK Query)

*(With Diagrams, Real Project Code, Mistakes & Edge Cases)*

> ğŸ¯ Goal: Test Redux like a senior engineer
> ğŸ¯ After this blog, youâ€™ll confidently test slices, async thunks, middleware, RTK Query, and full integration flows.

Testing is what separates mid-level from senior developers.

---

# ğŸ§  1ï¸âƒ£ What Should We Test in Redux?

In enterprise apps, we test:

* âœ… Reducers (unit)
* âœ… Async thunks
* âœ… Selectors
* âœ… Middleware
* âœ… RTK Query endpoints
* âœ… Component integration

Testing strategy matters.

---

# ğŸ— 2ï¸âƒ£ Redux Testing Architecture

![Image](https://i0.wp.com/automationstepbystep.com/mobufoc/2020/04/TestPyramid1.png?fit=1014%2C752\&ssl=1)

![Image](https://cdn-images-1.medium.com/max/800/0%2AysbTZG-Li1GgVzog.png)

![Image](https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)

![Image](https://miro.medium.com/1%2AgzSOKTC2V-mQhAJ-fc0qIA.jpeg)

Testing layers:

Unit Tests
â¬‡
Slice Tests
â¬‡
Async Logic Tests
â¬‡
Integration Tests
â¬‡
End-to-End Tests

Redux logic should mostly be unit-testable.

---

# ğŸ§ª 3ï¸âƒ£ Testing Reducers (Unit Testing)

Reducers are pure functions â†’ easiest to test.

---

## Example: cartSlice

```ts
interface CartState {
  items: { id: number; price: number }[];
  total: number;
}

const initialState: CartState = {
  items: [],
  total: 0
};
```

---

## Test File: cartSlice.test.ts

```ts id="9p9x8d"
import cartReducer, { addItem } from "./cartSlice";

describe("cart reducer", () => {
  it("should handle initial state", () => {
    expect(cartReducer(undefined, { type: "unknown" }))
      .toEqual({ items: [], total: 0 });
  });

  it("should add item correctly", () => {
    const previousState = { items: [], total: 0 };

    const result = cartReducer(
      previousState,
      addItem({ id: 1, price: 100 })
    );

    expect(result.items.length).toBe(1);
    expect(result.total).toBe(100);
  });
});
```

Pure. Clean. Fast.

---

# ğŸš€ 4ï¸âƒ£ Testing createAsyncThunk

Async testing requires mocking API.

---

## Example: loginUser thunk

---

## Test File

```ts id="u4ef3p"
import { loginUser } from "./authSlice";
import configureStore from "redux-mock-store";
import thunk from "redux-thunk";

const mockStore = configureStore([thunk]);

describe("loginUser thunk", () => {
  it("dispatches fulfilled on success", async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        json: () =>
          Promise.resolve({
            user: "Tushar",
            accessToken: "123"
          })
      })
    ) as jest.Mock;

    const store = mockStore({});

    await store.dispatch(
      loginUser({ email: "a", password: "b" }) as any
    );

    const actions = store.getActions();
    expect(actions[0].type).toContain("pending");
    expect(actions[1].type).toContain("fulfilled");
  });
});
```

We check:

* pending dispatched
* fulfilled dispatched

Not UI.
Only logic.

---

# ğŸ§  5ï¸âƒ£ Testing Selectors

Selectors must be deterministic.

---

```ts id="v8i36m"
import { selectFilteredProducts } from "./productsSelectors";

it("filters products correctly", () => {
  const state = {
    products: {
      entities: {
        1: { id: 1, title: "Phone" },
        2: { id: 2, title: "Laptop" }
      }
    },
    filters: { search: "phone" }
  };

  const result = selectFilteredProducts(state as any);

  expect(result.length).toBe(1);
});
```

No store needed.

Just pass mock state.

---

# ğŸ§© 6ï¸âƒ£ Testing Middleware

Example: logger middleware.

---

```ts id="lm87za"
const next = jest.fn();
const store = {
  getState: jest.fn(() => ({ count: 0 }))
};

loggerMiddleware(store)(next)({ type: "increment" });

expect(next).toHaveBeenCalled();
```

You test:

* Did middleware call next?
* Did it dispatch extra actions?
* Did it block action?

Middleware is just function chaining.

---

# ğŸ§ª 7ï¸âƒ£ Testing RTK Query

RTK Query needs MSW (Mock Service Worker) for realistic testing.

---

## Example Test with React Testing Library

```ts id="u3jowb"
import { render, screen } from "@testing-library/react";
import { Provider } from "react-redux";
import { store } from "../store";
import Products from "./Products";

test("renders products", async () => {
  render(
    <Provider store={store}>
      <Products />
    </Provider>
  );

  expect(await screen.findByText(/Phone/i)).toBeInTheDocument();
});
```

MSW intercepts API calls.

Test full integration.

---

# ğŸ”„ 8ï¸âƒ£ Integration Testing (Realistic Approach)

Test:

* Component
* Store
* Reducer
* Async logic

Together.

Example:

```ts id="m6w7ch"
render(
  <Provider store={store}>
    <LoginPage />
  </Provider>
);

fireEvent.click(screen.getByText("Login"));

expect(await screen.findByText("Dashboard"))
  .toBeInTheDocument();
```

Test user behavior.
Not implementation details.

---

# âš ï¸ 9ï¸âƒ£ Common Testing Mistakes

---

## âŒ Testing Redux Implementation Instead of Behavior

Bad:

```ts
expect(action.type).toBe("auth/login/fulfilled");
```

Better:

Test final state.

---

## âŒ Mocking Too Much

If you mock store, reducer, middleware together:

Test becomes meaningless.

Test smallest unit possible.

---

## âŒ Ignoring Error Cases

Always test:

* fulfilled
* rejected
* edge cases

---

## âŒ Not Resetting Mocks

Always:

```ts
afterEach(() => {
  jest.clearAllMocks();
});
```

---

# ğŸ§¨ 1ï¸âƒ£0ï¸âƒ£ Edge Cases

---

## ğŸ”¥ Async Race Conditions

Test scenario:

* Two dispatches
* First resolves slower

Ensure latest state is correct.

---

## ğŸ”¥ Testing Persisted State

Mock localStorage carefully.

Reset between tests.

---

## ğŸ”¥ Testing Token Refresh Middleware

Simulate:

* 401 response
* refresh success
* refresh failure

Ensure logout triggered correctly.

---

# ğŸ§  1ï¸âƒ£1ï¸âƒ£ Enterprise Testing Strategy

In large apps:

* 70% reducer & logic tests
* 20% integration tests
* 10% E2E tests

Redux logic is very testable.
Use that advantage.

---

# ğŸ¢ 1ï¸âƒ£2ï¸âƒ£ .NET Comparison (For You)

| Redux Testing    | .NET Equivalent           |
| ---------------- | ------------------------- |
| Reducer test     | Service unit test         |
| Thunk test       | Async service test        |
| Middleware test  | Pipeline handler test     |
| Integration test | Controller + Service test |
| MSW              | Mock API                  |

Redux architecture makes unit testing easy.

---

# ğŸ¯ 1ï¸âƒ£3ï¸âƒ£ Interview-Level Questions

You should answer:

* How to test createAsyncThunk?
* How to test middleware?
* How to test selectors?
* How to test RTK Query?
* Unit vs integration testing difference?
* Why reducers are easy to test?

---

# ğŸ“Œ Blog 18 Summary

You learned:

* Testing reducers
* Testing async thunks
* Testing selectors
* Testing middleware
* Testing RTK Query
* Integration testing
* Testing mistakes
* Enterprise testing strategy

Now you can build production-grade, testable Redux apps.


