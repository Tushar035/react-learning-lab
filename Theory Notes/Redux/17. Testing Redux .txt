# üìò Blog 17: Redux + TypeScript Complete Guide

*(Typed Hooks, Async Thunks, Entity Adapter Typing, Builder Pattern Typing, Enterprise Patterns, Edge Cases)*

> üéØ Goal: Write fully type-safe Redux code
> üéØ After this blog, you‚Äôll confidently use Redux Toolkit with TypeScript in production.

For high-paying frontend roles, TypeScript mastery is mandatory.

This blog is extremely important.

---

# üß† 1Ô∏è‚É£ Why TypeScript + Redux Matters

Without TypeScript:

* Action payload mistakes
* Wrong state access
* Incorrect dispatch usage
* Runtime bugs

With TypeScript:

* Compile-time safety
* Better IntelliSense
* Safer refactoring
* Enterprise-ready code

---

# üèó 2Ô∏è‚É£ Type Architecture Overview

![Image](https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2A0TOBMnLBg6gr-CMPiia2kg.png)

![Image](https://redux.js.org/assets/images/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif)

![Image](https://raw.githubusercontent.com/Svehla/typed-react-redux/master/imgs/new-redux-architecture.png)

Core types you must understand:

* RootState
* AppDispatch
* Typed hooks
* PayloadAction
* AsyncThunk types
* Entity adapter generics

---

# üè¢ 3Ô∏è‚É£ Typing the Store

## üìÅ store.ts

```ts
import { configureStore } from "@reduxjs/toolkit";
import authReducer from "../features/auth/authSlice";
import productsReducer from "../features/products/productsSlice";

export const store = configureStore({
  reducer: {
    auth: authReducer,
    products: productsReducer
  }
});
```

---

## üîπ RootState Type

```ts
export type RootState = ReturnType<typeof store.getState>;
```

Automatically infers state shape.

---

## üîπ AppDispatch Type

```ts
export type AppDispatch = typeof store.dispatch;
```

Ensures correct dispatch typing.

---

# üß† 4Ô∏è‚É£ Creating Typed Hooks (Best Practice)

Create reusable hooks.

## üìÅ hooks.ts

```ts
import { TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";
import type { RootState, AppDispatch } from "./store";

export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

Now use:

```ts
const dispatch = useAppDispatch();
const user = useAppSelector(state => state.auth.user);
```

Never use raw `useDispatch` or `useSelector` in TS projects.

---

# üß© 5Ô∏è‚É£ Typing createSlice Properly

---

## Example: Auth Slice

```ts
interface AuthState {
  user: string | null;
  accessToken: string | null;
  loading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  user: null,
  accessToken: null,
  loading: false,
  error: null
};
```

---

## Slice with PayloadAction

```ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    setUser: (state, action: PayloadAction<string>) => {
      state.user = action.payload;
    }
  }
});
```

`PayloadAction<T>` ensures correct payload type.

---

# üöÄ 6Ô∏è‚É£ Typing createAsyncThunk

This is where many developers struggle.

---

## Basic Typing

```ts
interface LoginCredentials {
  email: string;
  password: string;
}

interface LoginResponse {
  user: string;
  accessToken: string;
}

export const loginUser = createAsyncThunk<
  LoginResponse,
  LoginCredentials,
  { rejectValue: string }
>(
  "auth/login",
  async (credentials, thunkAPI) => {
    try {
      const response = await fetch("/api/login");
      return (await response.json()) as LoginResponse;
    } catch {
      return thunkAPI.rejectWithValue("Login failed");
    }
  }
);
```

Generic structure:

```ts
createAsyncThunk<
  ReturnType,
  ArgumentType,
  ThunkApiConfig
>()
```

Very important for enterprise-level TypeScript.

---

# üèó 7Ô∏è‚É£ Typing extraReducers with Builder

```ts
extraReducers: (builder) => {
  builder
    .addCase(loginUser.pending, (state) => {
      state.loading = true;
    })
    .addCase(loginUser.fulfilled, (state, action) => {
      state.user = action.payload.user;
    })
    .addCase(loginUser.rejected, (state, action) => {
      state.error = action.payload ?? "Unknown error";
    });
}
```

Builder automatically infers types.

Avoid writing manual action types.

---

# üß† 8Ô∏è‚É£ Typing createEntityAdapter

---

## Define Product Type

```ts
interface Product {
  id: number;
  title: string;
  price: number;
}
```

---

## Create Adapter

```ts
const productsAdapter = createEntityAdapter<Product>();
```

Fully typed.

Selectors also typed automatically:

```ts
const selectors = productsAdapter.getSelectors<RootState>(
  (state) => state.products
);
```

Type-safe selectById:

```ts
selectors.selectById(state, 1);
```

---

# ‚ö†Ô∏è 9Ô∏è‚É£ Common TypeScript Mistakes

---

## ‚ùå Using any

Bad:

```ts
const initialState: any = {};
```

Destroys type safety.

Never use `any` in Redux.

---

## ‚ùå Not Typing rejectValue

If you don‚Äôt type rejectValue:

`action.payload` becomes `unknown`.

Always specify:

```ts
{ rejectValue: string }
```

---

## ‚ùå Incorrect RootState Import

Import RootState from wrong file causes circular dependency.

Always define types in store file.

---

## ‚ùå Using useDispatch without typing

Default dispatch type is `Dispatch<AnyAction>`.

Lose async thunk typing.

Use typed hooks.

---

# üß® 1Ô∏è‚É£0Ô∏è‚É£ Edge Cases

---

## üî• Edge Case 1: Optional Payload

```ts
PayloadAction<string | undefined>
```

Handle carefully:

```ts
action.payload ?? "default"
```

---

## üî• Edge Case 2: Partial Updates

For updateOne:

```ts
productsAdapter.updateOne(state, {
  id: 1,
  changes: { price: 200 }
});
```

`changes` must match Partial<Product>.

---

## üî• Edge Case 3: Large Generic Types

Complex thunks with nested generics can get hard to read.

Use helper types for clarity.

---

# üè¢ 1Ô∏è‚É£1Ô∏è‚É£ Enterprise Type Strategy

Large apps:

* Strict mode enabled
* No implicit any
* Strict null checks
* Centralized types folder
* API response interfaces
* Separate DTO vs domain model

Frontend clean architecture.

---

# üß† 1Ô∏è‚É£2Ô∏è‚É£ .NET Comparison (For You)

| Redux + TS             | .NET Equivalent          |
| ---------------------- | ------------------------ |
| PayloadAction<T>       | Strongly typed DTO       |
| RootState              | Application state class  |
| Typed hooks            | Typed service injection  |
| Generic AsyncThunk     | Generic service method   |
| EntityAdapter<Product> | Dictionary<int, Product> |

TypeScript Redux feels similar to C# generics.

---

# üéØ 1Ô∏è‚É£3Ô∏è‚É£ Interview-Level Questions

You should answer:

* How to type createAsyncThunk?
* Why use PayloadAction?
* What is RootState?
* Why create typed hooks?
* How to type entityAdapter?
* Why avoid any?

---

# üìå Blog 17 Summary

You learned:

* RootState & AppDispatch typing
* Typed hooks best practice
* PayloadAction typing
* Async thunk generics
* Entity adapter typing
* Builder pattern inference
* Common TS mistakes
* Enterprise-level typing strategy

Now your Redux is fully type-safe and production-ready.


