# ğŸ“˜ Blog 8: Advanced `extraReducers` + Builder Pattern + `createEntityAdapter`

*(With Diagrams, Real Project Code, Mistakes & Edge Cases)*

> ğŸ¯ Goal: Learn how to scale Redux for large applications
> ğŸ¯ After this blog, youâ€™ll design state like a senior developer.

This blog is where Redux becomes **enterprise-ready**.

We will cover:

* Builder pattern in `extraReducers`
* Handling multiple async thunks cleanly
* State normalization
* `createEntityAdapter`
* Performance optimization
* Real-world architecture
* Edge cases

---

# ğŸ§  1ï¸âƒ£ Why We Need Advanced Patterns

In small apps:

```js
items: []
```

is fine.

But in real apps:

* 10,000 products
* Frequent updates
* Filtering
* Sorting
* Partial updates
* Caching

Simple array structure becomes slow and messy.

We need:

* Normalized state
* Efficient lookups
* Reusable reducers
* Clean async handling

---

# ğŸ— 2ï¸âƒ£ Builder Pattern in `extraReducers`

Earlier we wrote:

```js
extraReducers: (builder) => {
  builder
    .addCase(fetchProducts.pending, ...)
    .addCase(fetchProducts.fulfilled, ...)
}
```

Why builder?

Because:

* Better TypeScript support
* Safer action matching
* Scalable for many async actions

---

# ğŸ”„ 3ï¸âƒ£ Advanced Async Flow Diagram

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2AyYkitaR24SuFNXYyTxL1xA.gif)

![Image](https://redux.js.org/assets/images/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2AQERgzuzphdQz4e0fNs1CFQ.gif)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2A9lDu6F6XfDmzTsF3tCRDVA.png)

Flow with multiple thunks:

Component
â¬‡
dispatch(fetchProducts)
dispatch(deleteProduct)
dispatch(updateProduct)
â¬‡
extraReducers builder handles each case
â¬‡
State updates

Builder pattern allows clean separation.

---

# ğŸ¢ 4ï¸âƒ£ Real Project Example â€“ Large Product Catalog

We will build:

* Fetch products
* Add product
* Update product
* Delete product

With optimized structure.

---

# ğŸ§  5ï¸âƒ£ Why Normalize State?

Bad structure:

```js
{
  products: [
    { id: 1, name: "Phone" },
    { id: 2, name: "Laptop" }
  ]
}
```

Problems:

* Searching by id â†’ O(n)
* Updating â†’ map loop
* Duplicates possible
* Hard to manage relationships

Better structure (Normalized):

```js
{
  products: {
    ids: [1, 2],
    entities: {
      1: { id: 1, name: "Phone" },
      2: { id: 2, name: "Laptop" }
    }
  }
}
```

Benefits:

* O(1) lookup
* Easy update
* Easy delete
* No duplicates

---

# ğŸš€ 6ï¸âƒ£ Enter `createEntityAdapter`

Redux Toolkit provides:

```js
import { createEntityAdapter } from "@reduxjs/toolkit";
```

It automatically manages normalized state.

---

# ğŸ— 7ï¸âƒ£ Full Real Project Code

---

## ğŸ“ productsSlice.js

```js
import {
  createSlice,
  createAsyncThunk,
  createEntityAdapter
} from "@reduxjs/toolkit";

// 1ï¸âƒ£ Create adapter
const productsAdapter = createEntityAdapter({
  selectId: (product) => product.id,
  sortComparer: (a, b) => a.name.localeCompare(b.name)
});

// 2ï¸âƒ£ Get initial state
const initialState = productsAdapter.getInitialState({
  loading: false,
  error: null
});

// 3ï¸âƒ£ Async fetch
export const fetchProducts = createAsyncThunk(
  "products/fetch",
  async (_, thunkAPI) => {
    const response = await fetch("https://fakestoreapi.com/products");
    return await response.json();
  }
);

// 4ï¸âƒ£ Slice
const productsSlice = createSlice({
  name: "products",
  initialState,
  reducers: {
    productAdded: productsAdapter.addOne,
    productUpdated: productsAdapter.updateOne,
    productRemoved: productsAdapter.removeOne
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        productsAdapter.setAll(state, action.payload);
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

export const {
  productAdded,
  productUpdated,
  productRemoved
} = productsSlice.actions;

export default productsSlice.reducer;
```

This is production-grade structure.

---

# ğŸ§  8ï¸âƒ£ What `createEntityAdapter` Gives You

Automatically generated reducers:

* addOne
* addMany
* setAll
* updateOne
* removeOne
* removeAll

Automatically generated selectors:

```js
const selectors = productsAdapter.getSelectors(
  (state) => state.products
);
```

Example:

```js
selectors.selectAll(state);
selectors.selectById(state, 1);
```

Optimized and memoized.

---

# âš ï¸ 9ï¸âƒ£ Common Mistakes

---

## âŒ Mistake 1: Mixing Normalized and Non-Normalized Data

Bad:

```js
state.products.push(newProduct);
```

If using entityAdapter, never manually modify array.

Always use adapter methods.

---

## âŒ Mistake 2: Forgetting to Use Adapter in Fulfilled

Wrong:

```js
state.entities = action.payload;
```

Correct:

```js
productsAdapter.setAll(state, action.payload);
```

---

## âŒ Mistake 3: Ignoring Sort Comparer Performance

If sortComparer is heavy:

* Every insert triggers sorting
* Performance drops

Use only if necessary.

---

# ğŸ§¨ 1ï¸âƒ£0ï¸âƒ£ Edge Cases

---

## ğŸ”¥ Edge Case 1: Duplicate IDs

If API returns duplicate IDs:

Entity adapter will overwrite.

Solution:

Ensure backend uniqueness.

---

## ğŸ”¥ Edge Case 2: Large Dataset (10k+ items)

Normalized structure performs better.

But DevTools may slow down.

Solution:

Disable DevTools in production.

---

## ğŸ”¥ Edge Case 3: Partial Updates

Using:

```js
productsAdapter.updateOne(state, {
  id: 1,
  changes: { price: 2000 }
});
```

If id doesnâ€™t exist:

Nothing happens silently.

You must ensure existence.

---

# ğŸ§  1ï¸âƒ£1ï¸âƒ£ Builder Pattern Advanced Usage

You can match multiple actions:

```js
builder.addMatcher(
  (action) => action.type.endsWith("/rejected"),
  (state, action) => {
    state.error = action.error.message;
  }
);
```

This catches all rejected actions.

Very useful in large apps.

---

# ğŸ¢ 1ï¸âƒ£2ï¸âƒ£ Enterprise Folder Structure

```
features/
  products/
    productsSlice.js
    productsSelectors.js
    productsAPI.js
    ProductsPage.jsx
```

Feature-based architecture.

Scalable.

Clean.

---

# ğŸ§  1ï¸âƒ£3ï¸âƒ£ .NET Comparison (For You)

| Redux Pattern       | .NET Equivalent         |
| ------------------- | ----------------------- |
| createEntityAdapter | Dictionary<int, Entity> |
| ids + entities      | Lookup table            |
| Builder pattern     | Fluent API              |
| addMatcher          | Global exception filter |
| Normalization       | Database indexing       |

Entity adapter = frontend indexing system.

---

# ğŸ¯ 1ï¸âƒ£4ï¸âƒ£ Interview-Level Questions

You should answer:

* Why normalize state?
* What problems does createEntityAdapter solve?
* Difference between addOne and setAll?
* What is builder pattern?
* What is addMatcher?
* When to avoid sortComparer?

---

# ğŸ“Œ Blog 8 Summary

You learned:

* Advanced extraReducers builder pattern
* Why normalization matters
* How createEntityAdapter works
* Real large-scale product catalog example
* Performance awareness
* Edge cases
* Enterprise architecture mindset

Now you are designing Redux like a scalable system architect.

