ğŸ“˜ Blog 15 â€“ Redux Persist & State Rehydration

*(Persistence Strategy, Security Tradeoffs, Rehydration Lifecycle, Mistakes & Edge Cases)*

---

# ğŸ§  1ï¸âƒ£ Why Persistence Is Needed

Without persistence:

* Refresh page â†’ Redux state resets
* User logged out
* Cart emptied
* UI preferences lost

In real apps:

* Auth should survive refresh
* Cart should survive refresh
* Theme preference should survive refresh

Butâ€¦

âš ï¸ Persistence must be done carefully (security matters).

---

# ğŸ— 2ï¸âƒ£ How Redux Persist Works

Redux Persist stores Redux state into:

* localStorage
* sessionStorage
* AsyncStorage (React Native)

Then rehydrates it on app load.

---

# ğŸ”„ 3ï¸âƒ£ Persistence Flow Diagram

![Image](https://redux.js.org/assets/images/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif)

![Image](https://paulonteri.com/images/thoughts/react-redux/reduxdataflowdiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2AN4UwVQFMJUnUQOikbZ2laA.png)

![Image](https://miro.medium.com/1%2A4q5FloFr3QKWxdlWohr6Yg.jpeg)

Flow:

App starts
â¬‡
Redux store initializes
â¬‡
Persist reads localStorage
â¬‡
REHYDRATE action dispatched
â¬‡
Store merges persisted state
â¬‡
App renders with restored data

Important concept:

ğŸ‘‰ Rehydration lifecycle.

---

# ğŸ¢ 4ï¸âƒ£ Real Project Setup

---

## Step 1ï¸âƒ£ Install

```bash
npm install redux-persist
```

---

## Step 2ï¸âƒ£ Configure Persist

### ğŸ“ store.js

```js id="2jzmpa"
import { configureStore } from "@reduxjs/toolkit";
import { persistStore, persistReducer } from "redux-persist";
import storage from "redux-persist/lib/storage";
import rootReducer from "./rootReducer";

const persistConfig = {
  key: "root",
  storage,
  whitelist: ["cart", "auth"] // only persist these slices
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer
});

export const persistor = persistStore(store);
```

---

## Step 3ï¸âƒ£ Add PersistGate

```js id="m4yqzz"
import { PersistGate } from "redux-persist/integration/react";

root.render(
  <Provider store={store}>
    <PersistGate loading={<div>Loading...</div>} persistor={persistor}>
      <App />
    </PersistGate>
  </Provider>
);
```

Now:

State persists across refresh.

---

# ğŸ§  5ï¸âƒ£ Whitelist vs Blacklist

Whitelist = Only persist specific slices

```js
whitelist: ["cart"]
```

Blacklist = Persist everything except specified slices

```js
blacklist: ["ui"]
```

Best practice:

Prefer whitelist.

More secure.

---

# ğŸ” 6ï¸âƒ£ Security Strategy (Very Important)

âŒ Do NOT persist:

* Access tokens (if possible)
* Sensitive personal data
* Temporary server data

Better approach:

* Persist cart
* Persist theme
* Persist non-sensitive preferences
* Keep access token in memory
* Store refresh token in httpOnly cookie

Frontend persistence â‰  security.

---

# ğŸ§¨ 7ï¸âƒ£ Edge Cases

---

## ğŸ”¥ Edge Case 1: Rehydration Timing Issue

During startup:

Redux state is empty.
Then rehydration happens.

If component reads state before rehydration:

It may misbehave.

Solution:

Use `PersistGate`.

---

## ğŸ”¥ Edge Case 2: Versioning State

When app updates structure:

Old persisted state may break app.

Solution:

Use version + migration.

```js
const persistConfig = {
  key: "root",
  version: 2,
  storage,
  migrate: createMigrate(migrations, { debug: false })
};
```

Enterprise apps must handle migrations.

---

## ğŸ”¥ Edge Case 3: Logout But State Still in Storage

If you only clear Redux state:

localStorage still contains old data.

Proper logout:

```js
persistor.purge();
```

Or reset root reducer.

---

## ğŸ”¥ Edge Case 4: Huge State Size

localStorage limit â‰ˆ 5MB.

Storing large arrays:

* Slows down app
* May crash persistence

Never persist large datasets.

---

# âš ï¸ 8ï¸âƒ£ Common Mistakes

---

## âŒ Persisting Entire Store

Bad:

```js
whitelist: undefined
```

Persists everything.

Risky and unnecessary.

---

## âŒ Persisting Derived State

Never persist:

* loading flags
* error states
* filtered lists

Persist only base data.

---

## âŒ Ignoring Storage Limits

If cart grows too large:

Persistence fails silently.

Design carefully.

---

# ğŸ§  9ï¸âƒ£ Rehydration Lifecycle Deep Dive

On app start:

Redux dispatches:

```text
persist/REHYDRATE
```

Your reducers receive it.

You can react to it:

```js
extraReducers: (builder) => {
  builder.addCase("persist/REHYDRATE", (state, action) => {
    console.log("State restored");
  });
}
```

Advanced debugging technique.

---

# ğŸ¢ 1ï¸âƒ£0ï¸âƒ£ Enterprise Persistence Strategy

Large apps often:

* Persist only auth refresh token indicator
* Use backend session for sensitive data
* Reset entire store on logout
* Use versioning for migrations
* Encrypt persisted data (optional)

Encryption example:

Use transform:

```js
import { createTransform } from "redux-persist";
```

Advanced security.

---

# ğŸ§  1ï¸âƒ£1ï¸âƒ£ .NET Comparison (For You)

| Redux Persist | .NET Equivalent             |
| ------------- | --------------------------- |
| localStorage  | Browser session             |
| REHYDRATE     | Application startup restore |
| whitelist     | Selective caching           |
| migrate       | DB migration                |
| purge         | Clear session               |

Think of it like client-side session management.

---

# ğŸ¯ 1ï¸âƒ£2ï¸âƒ£ Interview-Level Questions

You should answer:

* What is rehydration?
* Why use whitelist instead of blacklist?
* Why not persist access tokens?
* How to reset persisted state on logout?
* What happens if state schema changes?
* How to handle migration?

---

# ğŸ“Œ Blog 15 Summary

You learned:

* Why persistence matters
* How Redux Persist works
* Rehydration lifecycle
* Security best practices
* Migration strategy
* Logout handling
* Storage limitations
* Enterprise-level edge cases

Now your Redux app survives refresh safely.

